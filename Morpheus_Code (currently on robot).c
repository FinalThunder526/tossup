#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(Sensor, in1,    ArmPotentiometer, sensorPotentiometer)
#pragma config(Sensor, in2,    Gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  RightMorpheus,  sensorDigitalOut)
#pragma config(Sensor, dgtl2,  LeftMorpheus,   sensorDigitalOut)
#pragma config(Motor,  port1,            ,             tmotorVex393, openLoop)
#pragma config(Motor,  port2,           LeftBackMotor1, tmotorVex393HighSpeed, openLoop)
#pragma config(Motor,  port3,           LeftBackMotor2, tmotorVex393HighSpeed, openLoop)
#pragma config(Motor,  port4,           RightBackMotor1, tmotorVex393HighSpeed, openLoop, reversed)
#pragma config(Motor,  port5,           RightBackMotor2, tmotorVex393HighSpeed, openLoop, reversed)
#pragma config(Motor,  port6,           LeftFrontMotor1, tmotorVex393HighSpeed, openLoop)
#pragma config(Motor,  port7,           RightFrontMotor1, tmotorVex393HighSpeed, openLoop, reversed)
#pragma config(Motor,  port8,           Intake,        tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port9,           Arm1,          tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port10,          Arm2,          tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(105)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

//  Lucky Programming Clover
//           .-.
//          ( . )
//        .-.':'.-.
//       (  =,!,=  )
//        '-' | '-'


#define TURN_SPEED 2 // quickness with which the robot turns in response to right thumbstick

int armRotation = SensorValue[ArmPotentiometer];
int morpheus = 0; // state of drive orientation: 0 = tank, 1 = x-drive
int armSpeedPrevious = 0;

// Uses a cubic function to make the acceleration smooth and not jerky or sudden.
// x is the input value of the joystick, return is the y value mapped along a cubic map
int cubicMap(int x)
{
	return ((((x*3)/25)*((x*3)/25)*((x*3)/25)/27 + x/2)*2)/3;
}


// All activities that occur before the competition starts
// Example: clearing encoders, setting servo positions, ...
void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
  // Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;
}


// controls movement of the robot
void UC_drive() {
	if(vexRT[Btn8L]) {
		morpheus = 1;
  } else if (vexRT[Btn8R]) {
		morpheus = 0;
	}

  SensorValue[RightMorpheus] = morpheus;
	SensorValue[LeftMorpheus] = morpheus;

  int channel1 = cubicMap(vexRT[Ch1]);
	int channel3 = cubicMap(vexRT[Ch3]);
	int channel4 = cubicMap(vexRT[Ch4]);
	if(morpheus == 0) {
	// tank drive
    motor(LeftFrontMotor1) = motor(LeftBackMotor1) = motor(LeftBackMotor2) = channel3 + TURN_SPEED*channel1;
	  motor(RightFrontMotor1) = motor(RightBackMotor1) = motor(RightBackMotor2) = channel3 - TURN_SPEED*channel1;
  } else {
  // x-drive
  	motor(LeftFrontMotor1) = channel3 + channel4 + channel1;
	  motor(RightFrontMotor1) = channel3 - channel4 - channel1;
	  motor(LeftBackMotor1) = motor(LeftBackMotor2) = channel3 - channel4 + channel1;
	  motor(RightBackMotor1) = motor(RightBackMotor2) = channel3 + channel4 - channel1;
  }
}

void updateSensors() {
  	armRotation = SensorValue[ArmPotentiometer];
}

// allocates the specified arm power to the arm motors
void powerArm(int speed) {
	motor(Arm1) = motor(Arm2) = speed;
}

// brings the arm to a gradual stop
void stopArm() {
	if (armSpeedPrevious > 10) {
		armSpeedPrevious -= 1;
		powerArm(armSpeedPrevious);
	} else if(armSpeedPrevious < -10) {
		armSpeedPrevious += 1;
		powerArm(armSpeedPrevious);
	}
}

// controls the algorithm in determining arm speed
void moveArm(int target) {
	if(target > 0) {
		int tempSpeed = armSpeedPrevious + ((127-armSpeedPrevious)/5);
		powerArm(tempSpeed);
		armSpeedPrevious = tempSpeed;
	} else if (target < 0) {
		int tempSpeed = armSpeedPrevious - ((127+armSpeedPrevious)/5);
		powerArm(tempSpeed);
		armSpeedPrevious = tempSpeed;
	} else {
		stopArm();
	}
}

// controls arm movement of robot
void UC_arm(bool safe) {
	if(safe) {
		if (vexRT[Btn5U] == 1 && vexRT[Btn5D] == 1) {
	    	moveArm(0);
	 	} else if (vexRT[Btn5U] == 1) {  	 // bring the arm up
	    	moveArm(127);
		} else if (vexRT[Btn5D] == 1) {	 // bring the arm down
	      moveArm(-127);
	    } else {											// don't do anything to the arm
	      moveArm(0);
	    }
	} else {
		if (vexRT[Btn5U] == 1 && vexRT[Btn5D] == 1) {
	    	moveArm(0);
	 	} else if (vexRT[Btn5U] == 1) {  	 // bring the arm up
	    	moveArm(127);
		} else if (vexRT[Btn5D] == 1) {	 // bring the arm down
	      moveArm(-127);
	    } else {						// don't do anything to the arm
	      moveArm(0);
	    }
	}
}

void UC_intake() {
	if(vexRT[Btn6U]) {
		motor(Intake) = 127;
	}
	else if (vexRT[Btn6D]) {
		motor(Intake) = -127;
	} else {
		motor(Intake) = 0;
	}
}

bool toggle(bool a) {
	return !a;
}

// COMPETITION METHODS
task autonomous()
{

}

task usercontrol()
{
	while (true) {
		updateSensors(); // updates all sensors
		UC_drive();  // allows for movement of the robot
		UC_arm(1); // allows for movement of the arm
		UC_intake();
	}
}
