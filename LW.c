#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    ArmPotentiometer, sensorPotentiometer)
#pragma config(Sensor, in2,    Gyro,           sensorGyro)
#pragma config(Sensor, in3,    LeftLine,       sensorLineFollower)
#pragma config(Sensor, in5,    RightLine,      sensorLineFollower)
#pragma config(Sensor, dgtl1,  Morpheus,       sensorDigitalOut)
#pragma config(Sensor, dgtl2,  Catapult,       sensorDigitalOut)
#pragma config(Sensor, dgtl12, Button,         sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           IntakeLeft,    tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port2,           DriveFrontLeft, tmotorVex393HighSpeed, openLoop)
#pragma config(Motor,  port3,           DriveFrontRight, tmotorVex393HighSpeed, openLoop, reversed)
#pragma config(Motor,  port4,           DriveBackLeft, tmotorVex393HighSpeed, PIDControl, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,  port5,           DriveBackRight, tmotorVex393HighSpeed, PIDControl, reversed, encoder, encoderPort, I2C_2, 1000)
#pragma config(Motor,  port6,           DriveCenter,   tmotorVex393HighSpeed, openLoop)
#pragma config(Motor,  port7,           Arm1,          tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port8,           Arm2,          tmotorVex393, PIDControl, encoder, encoderPort, I2C_3, 1000)
#pragma config(Motor,  port9,           Arm3,          tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port10,          IntakeRight,   tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(105)


#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

//  Lucky Programming Clover
//           .-.
//          ( . )
//        .-.':'.-.
//       (  =,!,=  )
//        '-' | '-'


#define TURN_SPEED 2 // quickness with which thejm  robot turns in response to right thumbstick
#define encoderMotor DriveBackLeft

#define driveThreshold 64
#define joystickThreshold 127

#define armSpeed 110

int armRotation = SensorValue[ArmPotentiometer];
int armSpeedPrevious = 0;

int morpheus = 0; // state of drive orientation: 0 = tank, 1 = x-drive

int oldY;

int channel1 = 0, channel3 = 0, channel4 = 0;
int isBeingIntaken;

// Uses a cubic function to make the acceleration smooth and not jerky or sudden.
// x is the input value of the joystick, return is the y value mapped along a cubic map
int cubicMap(int x)
{
	return ((((x*3)/25)*((x*3)/25)*((x*3)/25)/27 + x/2)*2)/3;
}


// All activities that occur before the competition starts
// Example: clearing encoders, setting servo positions, ...
task pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
  // Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;
}

// Base Movement Function
// c1 turns, c3 forward, c4 strafes
void move(int c1, int c3, int c4) {
		motor(DriveBackLeft) = motor(DriveFrontLeft) = /*(current + change)*/ c3 + TURN_SPEED*c1;
		motor(DriveBackRight) = motor(DriveFrontRight) = /*(current + change)*/ c3 - TURN_SPEED*c1;
}

void setMorpheus() {
	SensorValue[Morpheus] = 1;

}
void setTank() {
	SensorValue[Morpheus] = 0;
}

// Piecewise function for basic movement. Smooths.
// x is the input, ranging from -127 to 127
int driveFunction(int x) {
	bool isNeg = false;
	if (x < 0)
		isNeg = true;
	int y = x;
	x = abs(x);
	int aAt64 = 1.89; // This is the acceleration at the transition point.
	// This is a cubic function.
	if(x < driveThreshold) {
		y = x * x * x / 4096;
	}
	// This is an a < 0 parabola, starting at (64, 64) and going to (127, 127)
	// y = -0.01587(x - 127)^2 + 127
	else if (x < joystickThreshold) {
		y = -0.01587 * (x - 127) * (x - 127) + 127;
	}
	if (isNeg) {y *= -1;}
	return y;
}

void UC_buttons() {
	if(vexRT[Btn8L]) {
		setMorpheus();
  } else if (vexRT[Btn8R]) {
		setTank();
	}
	if(vexRT[Btn8D]) {
		SensorValue[Catapult] = 1;
	} else {
		SensorValue[Catapult] = 0;
	}
}

// controls movement of the robot
void UC_drive() {

	oldY = channel3;

  channel1 = cubicMap(vexRT[Ch1]);
	channel3 = cubicMap(vexRT[Ch3]);
	channel4 = cubicMap(vexRT[Ch4]);

	// Testing function
	/*
	channel1 = driveFunction(channel1);
	channel3 = driveFunction(channel3);
	channel4 = driveFunction(channel4);*/

	move(channel1, channel3, channel4);
}

int encoderValue = 0;

void updateSensors() {
  armRotation = SensorValue[ArmPotentiometer];
  encoderValue = nMotorEncoder[DriveBackLeft];
}

// allocates the specified arm power to the arm motors
void powerArm(int speed) {
	motor(Arm1) = motor(Arm2) = motor(Arm3) = speed;
}

// brings the arm to a gradual stop
void stopArm() {
	if (armSpeedPrevious > 10) {
		armSpeedPrevious -= 1;
		powerArm(armSpeedPrevious);
	} else if(armSpeedPrevious < -10) {
		armSpeedPrevious += 1;
		powerArm(armSpeedPrevious);
	}
}

// controls the algorithm in determining arm speed
void moveArm(int target) {
	if(target > 0 /*&& armRotation < 1250*/) {
		int tempSpeed = armSpeedPrevious + ((127-armSpeedPrevious)/5);
		powerArm(tempSpeed);
		armSpeedPrevious = tempSpeed;
	} else if (target < 0 && armRotation > 0) {
		int tempSpeed = armSpeedPrevious - ((127+armSpeedPrevious)/5);
		powerArm(tempSpeed);
		armSpeedPrevious = tempSpeed;
	} else {
		stopArm();
	}
}

// controls arm movement of robot
void UC_arm(bool safe) {
	if(safe) {
		if (vexRT[Btn5U] == 1 && vexRT[Btn5D] == 1) {
	    	moveArm(0);
	 	} else if (vexRT[Btn5U] == 1) {  	 // bring the arm up
	    	moveArm(127);
		} else if (vexRT[Btn5D] == 1) {	 // bring the arm down
	      moveArm(-127);
	    } else {											// don't do anything to the arm
	      moveArm(0);
	    }
	} else {
		if (vexRT[Btn5U] == 1 && vexRT[Btn5D] == 1) {
	    	moveArm(0);
	 	} else if (vexRT[Btn5U] == 1) {  	 // bring the arm up
	    	moveArm(127);
		} else if (vexRT[Btn5D] == 1) {	 // bring the arm down
	      moveArm(-127);
	  } else {						// don't do anything to the arm
	      moveArm(0);
	  }
	}
}

void UC_intake() {
	if(vexRT[Btn6U]) {
		isBeingIntaken = true;
		motor(IntakeLeft) = 127;
		motor(IntakeRight) = 127;
	}	else if (vexRT[Btn6D]) {
		motor(IntakeLeft) = -127;
		motor(IntakeRight) = -127;
	} else {
		isBeingIntaken = false;
		motor(IntakeLeft) = 0;
		motor(IntakeRight) = 0;
	}
}

bool toggle(bool a) {
	return !a;
}

//////////////////////////////////////////////////////////////////////////////
//														MOVEMENT																			//
//////////////////////////////////////////////////////////////////////////////

void intakeT(int time) {
	motor(IntakeLeft) = motor(IntakeRight) = 127;
	wait1Msec(time);
	motor(IntakeLeft) = motor(IntakeRight) = 0;
}
void outtakeT(int time) {
	motor(IntakeLeft) = motor(IntakeRight) = -127;
	wait1Msec(time);
	motor(IntakeLeft) = motor(IntakeRight) = 0;
}

void startAuton() {
	intakeT(700);
}

int isUnderValue(int value) {
	return (nMotorEncoder[DriveBackLeft] < value) && (nMotorEncoder[DriveBackRight] > -value);
}

// Basic movement, given the three controller channels 1, 3, and 4.
void basicMove(int c1, int c3, int c4) {
	if(morpheus == 0) {
		motor(DriveFrontLeft) = motor(DriveBackLeft) = c3 + TURN_SPEED*channel1;
	  motor(DriveFrontRight) = motor(DriveBackRight) = c3 - TURN_SPEED*channel1;
	} else if (morpheus == 1) {
		motor(DriveFrontLeft) = c3 + c4 + c1;
		motor(DriveFrontRight) = c3 - c4 - c1;
		motor(DriveBackLeft) = c3 - c4 + c1;
		motor(DriveBackRight) = c3 + c4 - c1;
	}
}

void raiseArm(int target) {
	while(armRotation < target) {
		powerArm(armSpeed);
		updateSensors();
	}
}
void lowerArm(int target) {
	while(armRotation > target) {
		powerArm(-armSpeed);
		updateSensors();
	}
}

void waitForButton() {
	while(SensorValue[Button] == 0) {
		wait1Msec(10);
	}
}

//////////////////////////////////////////////////////////////////////////
//																																			//
//													AUTONOMOUS METHODS 													//
//																																			//
//////////////////////////////////////////////////////////////////////////

void forward(int distance) {
	nMotorEncoder[DriveBackLeft] = 0;
	while(nMotorEncoder[DriveBackLeft] < distance) {
		motor[DriveBackLeft] = motor[DriveBackRight] = 100;
		motor[DriveFrontLeft] = motor[DriveFrontRight] = 100;
	}
	motor[DriveBackLeft] = motor[DriveBackRight] = 0;
	motor[DriveFrontLeft] = motor[DriveFrontRight] = 0;
}

void back(int distance) {
	nMotorEncoder[DriveBackLeft] = 0;
	while(nMotorEncoder[DriveBackLeft] > -distance) {
		motor[DriveBackLeft] = motor[DriveBackRight] = -100;
		motor[DriveFrontLeft] = motor[DriveFrontRight] = -100;
	}
	motor[DriveBackLeft] = motor[DriveBackRight] = 0;
	motor[DriveFrontLeft] = motor[DriveFrontRight] = 0;
}

void left(int distance) {
	nMotorEncoder[DriveBackLeft] = nMotorEncoder[DriveBackRight] = 0;
	while(nMotorEncoder[DriveBackLeft] > 150 && nMotorEncoder[DriveBackRight] < 150) {
		motor[DriveBackLeft] = motor[DriveFrontLeft] = -127;
		motor[DriveBackRight] = motor[DriveBackRight] = 127;
	}
	motor[DriveBackLeft] = motor[DriveBackRight] = 0;
	motor[DriveFrontLeft] = motor[DriveFrontRight] = 0;
}
void right() {
}

void stopEverything() {
	powerArm(0);
	basicMove(0, 0, 0);
}

// 12 with hand adjustments
// Most basic
void lolBeavers() {
	setTank();
	powerArm(0);
	raiseArm(2250);
	powerArm(30);
	forward(580);
	//wait1Msec(1000);
	basicMove(0, 0, 0);
	wait1Msec(200);
	back(600);
	basicMove(0, 0, 0);
	wait1Msec(2000);
	motor(IntakeLeft) = motor(IntakeRight) = -127;
	forward(790);
	//wait1Msec(1000);
	basicMove(0, 40, 0);
	basicMove(0, -40, 0);
	basicMove(0, 0, 0);
	wait1Msec(1000);
	back(810);
	basicMove(0, 0, 0);
}

// Hangside basic
// Picks up the hangside, turns around, outtakes.
void lolBats() {
	motor(IntakeLeft) =motor(IntakeRight) = 127;
	forward(60);
	wait1Msec(1500);
	back(65);
	basicMove(0, 0, 0);
	wait1Msec(2000);
	//raiseArm(300);
	//outtakeT(2000);
	motor(IntakeLeft) = motor(IntakeRight) = 0;

	powerArm(0);
	basicMove(0, 0, 0);
	raiseArm(600);
	powerArm(20);
	waitForButton();
	outtakeT(3500);
	basicMove(0, 0, 0);
	powerArm(0);
	basicMove(0, 0, 0);
}

// Hangside pushing shiz over.
void lolWalruses() {
	setTank();
	powerArm(0);
	raiseArm(1700);
	//right(100);
}

// Like the dodo, it does nothing. :D
void lolDodo() { }

void lolTRex() {
	/*lolBeavers();*/
	wait1Msec(2500);
	lowerArm(1650);
	forward(1200);
	left(140);
}

// Using antitips, tips the big ball into the tray, then scores both bucky and big balls. :O :D
void lolHippos() {

}

/*
void forLols() {
	setTank();
	powerArm(0);
	raiseArm(650);
	powerArm(10);
	motor[IntakeLeft] = motor[IntakeRight] = -127;
	forward(430);
	wait1Msec(1000);
	back(430);
	basicMove(0, 0, 0);
	//waitForButton();
	wait1Msec(4000);
	forward(480);
	wait1Msec(1000);
	back(500);
	basicMove(0, 0, 0);
	lowerArm(0);
	motor[IntakeLeft] = motor[IntakeRight] = 0;
	basicMove(0, 0, 0);
}

// Most basic, scores preload, knocks over big balls.
void forGreaterJustice() {
	setTank();
	forward(1100);
	raiseArm(1200);
	powerArm(10);
	//back(50);
	basicMove(0, 0, 0);
	motor(IntakeLeft) =motor(IntakeRight) = -127;
	wait1Msec(800);
	back(400);
	motor(IntakeLeft) =motor(IntakeRight) = 0;
	lowerArm(10);
	back(600);
	basicMove(0, 0, 0);
	waitForButton();
	// Push over big balls
	//raiseArm(650);
	powerArm(0);
	//stopArm();
	motor[Arm1] = motor[Arm2] = 0;
	forLols();
}

void forMuricaAndForAslan() {
	setTank();
	forward(1600);
	setMorpheus();
	basicMove(0, 10, -127);
	wait1Msec(1000);
	basicMove(0, 0, 0);
	raiseArm(1200);
	powerArm(10);
	setTank();
	forward(470);
	basicMove(0, 0, 0);
	outtakeT(1200);
	back(600);
	basicMove(0, 0, 0);
}
*/

task Display_LCD(){
  bLCDBacklight = true;
  while(true){
    // Converting autonN to a string.
    //string autonNstring = autonN;

    // Battery level indicator
    string display = "R:";
  	string regularBat, backupBat;
    StringFormat(regularBat, "%1.2f", (float)nImmediateBatteryLevel/1000);
    //StringFormat(expand_bat, "%1.2f", (float)SensorValue[]/275);
    StringFormat(backupBat, "%1.2f", (float)BackupBatteryLevel/1000);
    StringConcatenate(display, regularBat);
    StringConcatenate(display, "V B:");
    StringConcatenate(display, backupBat);
    StringConcatenate(display, "V ");

    clearLCDLine(0);
    clearLCDLine(1);

    if(vexRT[Btn7L] == 1)
    {
    	displayLCDCenteredString(0, "Battery Power:");
    	displayLCDCenteredString(1, display);
  	}
    else
    {
    	if((float)nImmediateBatteryLevel/1000 < 6.45)
    	{
    		displayLCDCenteredString(0, "***WARNING***");
    		displayLCDCenteredString(1, "*LOW BATTERY*");
    	}
    	else
    	{
    		// Default screen:
    		string left = SensorValue[LeftLine];
    		string right = SensorValue[RightLine];
    		string arm = armRotation;
    		string lolbeav = isBeingIntaken;
    		displayLCDCenteredString(0, left);
    	  displayLCDCenteredString(1, lolbeav);
    	}
    }
    wait1Msec(100);
  }
}

// COMPETITION METHODS
task autonomous()
{
	//StartTask(Display_LCD);
	startAuton();
	setTank();

	lolBeavers();
}

task usercontrol()
{
	nMotorEncoder[encoderMotor] = 0;
	//motor[Flash] = 127;
	while (true) {
		//displayLCDCenteredString(0, "Hello");
		StartTask(Display_LCD);
		updateSensors(); // updates all sensors
		UC_drive();  // allows for movement of the robot
		UC_arm(1); // allows for movement of the arm
		UC_intake();
		UC_buttons();
	}
}

/* OLD LINE FOLLOWING CODE
/*if(!rightOfRight) {
				rightOfRight = true;
				timesHitLine++;
				wait1Msec(80);
			}
			else {
				leftMotor = 30;
				rightMotor = 60;
			}*/
			//else
			//{ leftMotor = 45;
			//	rightMotor = 60; }
			//leftMotor = 45;//127 - ((2000 - SensorValue[RightLine])/8);*/
