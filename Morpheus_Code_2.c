#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    ArmPotentiometer, sensorPotentiometer)
#pragma config(Sensor, in2,    Gyro,           sensorGyro)
#pragma config(Sensor, in3,    LeftLine,       sensorLineFollower)
#pragma config(Sensor, in5,    RightLine,      sensorLineFollower)
#pragma config(Sensor, dgtl1,  RightMorpheus,  sensorDigitalOut)
#pragma config(Sensor, dgtl2,  LeftMorpheus,   sensorDigitalOut)
#pragma config(Sensor, dgtl3,  Button,         sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           Intake1,       tmotorVex393HighSpeed, openLoop, reversed)
#pragma config(Motor,  port2,           LeftBackMotor1, tmotorVex393HighSpeed, openLoop, encoder, encoderPort, I2C_2, 1000)
#pragma config(Motor,  port3,           LeftBackMotor2, tmotorVex393HighSpeed, openLoop)
#pragma config(Motor,  port4,           RightBackMotor1, tmotorVex393HighSpeed, openLoop, reversed, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,  port5,           RightBackMotor2, tmotorVex393HighSpeed, openLoop, reversed)
#pragma config(Motor,  port6,           LeftFrontMotor1, tmotorVex393HighSpeed, openLoop)
#pragma config(Motor,  port7,           RightFrontMotor1, tmotorVex393HighSpeed, openLoop, reversed)
#pragma config(Motor,  port8,           Arm1,          tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port9,           Intake2,       tmotorVex393HighSpeed, openLoop, reversed)
#pragma config(Motor,  port10,          Arm2,          tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(105)


#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

//  Lucky Programming Clover
//           .-.
//          ( . )
//        .-.':'.-.
//       (  =,!,=  )
//        '-' | '-'


#define TURN_SPEED 2 // quickness with which the robot turns in response to right thumbstick

int armRotation = SensorValue[ArmPotentiometer];
int armSpeedPrevious = 0;

int morpheus = 0; // state of drive orientation: 0 = tank, 1 = x-drive

int oldY;

int channel1 = 0, channel3 = 0, channel4 = 0;
int pause = 30;

int autonN = 0;
int isBeingIntaken;

// Uses a cubic function to make the acceleration smooth and not jerky or sudden.
// x is the input value of the joystick, return is the y value mapped along a cubic map
int cubicMap(int x)
{
	return ((((x*3)/25)*((x*3)/25)*((x*3)/25)/27 + x/2)*2)/3;
}


// All activities that occur before the competition starts
// Example: clearing encoders, setting servo positions, ...
void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
  // Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;
}

// c1 turns, c3 forward, c4 strafes
void move(int c1, int c3, int c4) {
	if(morpheus == 0) { // tank drive
		// Basically splits up the movement by dv, the difference between the intended speed and the current speed of the motors.
	  int target = c3;
		int current = motor[LeftBackMotor1];//(motor[LeftBackMotor1] + motor[RightBackMotor1] + motor[RightBackMotor2] + motor[LeftBackMotor2] + motor[LeftFrontMotor1] + motor[RightFrontMotor1])/6;
		int dv = target - current;
		int change = dv;
		// Case 1: More than 127; this indicates that the robot is moved from forward to backward.
	  if (abs(dv) > 127) {
	  	change = dv/3;
		} else if (abs(dv) > 70) {
			change = dv/2;
		} else if (abs(dv) > 25) {
			change = dv * 2/3;
		} else {
			change = dv;
		}
		motor(LeftFrontMotor1) = motor(LeftBackMotor1) = motor(LeftBackMotor2) = (current + change) + TURN_SPEED*c1;
		motor(RightFrontMotor1) = motor(RightBackMotor1) = motor(RightBackMotor2) = (current + change) - TURN_SPEED*c1;

		/*
		if((oldY < 0 && c3 > 0) || (oldY > 0 && c3 < 0)) {
			motor(LeftFrontMotor1) = motor(LeftBackMotor1) = motor(LeftBackMotor2) = 0;//c3 + TURN_SPEED*channel1;
			motor(RightFrontMotor1) = motor(RightBackMotor1) = motor(RightBackMotor2) = 0;//c3 - TURN_SPEED*channel1;
			wait1Msec(pause);
			oldY = 0;
  	} else {
	  	motor(LeftFrontMotor1) = motor(LeftBackMotor1) = motor(LeftBackMotor2) = c3 + TURN_SPEED*channel1;
	  	motor(RightFrontMotor1) = motor(RightBackMotor1) = motor(RightBackMotor2) = c3 - TURN_SPEED*channel1;
  	}*/
  } else if (morpheus == 1) { // x-drive
  	motor(LeftFrontMotor1) = c3 + c4 + c1;
		motor(RightFrontMotor1) = c3 - c4 - c1;
		motor(LeftBackMotor1) = motor(LeftBackMotor2) = c3 - c4 + c1;
		motor(RightBackMotor1) = motor(RightBackMotor2) = c3 + c4 - c1;
  }
}

void setMorpheus() {
	morpheus = 1;
	SensorValue[RightMorpheus] = morpheus;
	SensorValue[LeftMorpheus] = morpheus;

}
void setTank() {
	morpheus = 0;
	SensorValue[RightMorpheus] = morpheus;
	SensorValue[LeftMorpheus] = morpheus;

}

// controls movement of the robot
void UC_drive() {
	if(vexRT[Btn8L]) {
		setMorpheus();
  } else if (vexRT[Btn8R]) {
		setTank();
	}

	oldY = channel3;

  channel1 = cubicMap(vexRT[Ch1]);
	channel3 = cubicMap(vexRT[Ch3]);
	channel4 = cubicMap(vexRT[Ch4]);

	move(channel1, channel3, channel4);
}

void updateSensors() {
  armRotation = SensorValue[ArmPotentiometer];
}

// allocates the specified arm power to the arm motors
void powerArm(int speed) {
	motor(Arm1) = motor(Arm2) = speed;
}

// brings the arm to a gradual stop
void stopArm() {
	if (armSpeedPrevious > 10) {
		armSpeedPrevious -= 1;
		powerArm(armSpeedPrevious);
	} else if(armSpeedPrevious < -10) {
		armSpeedPrevious += 1;
		powerArm(armSpeedPrevious);
	}
}

// controls the algorithm in determining arm speed
void moveArm(int target) {
	if(target > 0 /*&& armRotation < 1250*/) {
		int tempSpeed = armSpeedPrevious + ((127-armSpeedPrevious)/5);
		powerArm(tempSpeed);
		armSpeedPrevious = tempSpeed;
	} else if (target < 0 && armRotation > 0) {
		int tempSpeed = armSpeedPrevious - ((127+armSpeedPrevious)/5);
		powerArm(tempSpeed);
		armSpeedPrevious = tempSpeed;
	} else {
		stopArm();
	}
}

// controls arm movement of robot
void UC_arm(bool safe) {
	if(safe) {
		if (vexRT[Btn5U] == 1 && vexRT[Btn5D] == 1) {
	    	moveArm(0);
	 	} else if (vexRT[Btn5U] == 1) {  	 // bring the arm up
	    	moveArm(127);
		} else if (vexRT[Btn5D] == 1) {	 // bring the arm down
	      moveArm(-127);
	    } else {											// don't do anything to the arm
	      moveArm(0);
	    }
	} else {
		if (vexRT[Btn5U] == 1 && vexRT[Btn5D] == 1) {
	    	moveArm(0);
	 	} else if (vexRT[Btn5U] == 1) {  	 // bring the arm up
	    	moveArm(127);
		} else if (vexRT[Btn5D] == 1) {	 // bring the arm down
	      moveArm(-127);
	  } else {						// don't do anything to the arm
	      moveArm(0);
	  }
	}
}

void UC_intake() {
	if(vexRT[Btn6U]) {
		isBeingIntaken = true;
		motor(Intake1) = 127;
		motor(Intake2) = 127;
	}	else if (vexRT[Btn6D]) {
		motor(Intake1) = -127;
		motor(Intake2) = -127;
	} else {
		isBeingIntaken = false;
		motor(Intake1) = 0;
		motor(Intake2) = 0;
	}
}

bool toggle(bool a) {
	return !a;
}

//////////////////////////////////////////////////////////////////////////////
//														MOVEMENT																			//
//////////////////////////////////////////////////////////////////////////////

void intakeT(int time) {
	motor(Intake1) = motor(Intake2) = 127;
	wait1Msec(time);
	motor(Intake1) = motor(Intake2) = 0;
}
void outtakeT(int time) {
	motor(Intake1) = motor(Intake2) = -127;
	wait1Msec(time);
	motor(Intake1) = motor(Intake2) = 0;
}

void startAuton() {
	intakeT(700);
}

int isUnderValue(int value) {
	return (nMotorEncoder[LeftBackMotor1] < value) && (nMotorEncoder[RightBackMotor1] > -value);
}

// Basic movement, given the three controller channels 1, 3, and 4.
void basicMove(int c1, int c3, int c4) {
	if(morpheus == 0) {
		motor(LeftFrontMotor1) = motor(LeftBackMotor1) = motor(LeftBackMotor2) = c3 + TURN_SPEED*channel1;
	  motor(RightFrontMotor1) = motor(RightBackMotor1) = motor(RightBackMotor2) = c3 - TURN_SPEED*channel1;
	} else if (morpheus == 1) {
		motor(LeftFrontMotor1) = c3 + c4 + c1;
		motor(RightFrontMotor1) = c3 - c4 - c1;
		motor(LeftBackMotor1) = motor(LeftBackMotor2) = c3 - c4 + c1;
		motor(RightBackMotor1) = motor(RightBackMotor2) = c3 + c4 - c1;
	}
}

void smoothForward(int distance) {
	nMotorEncoder[LeftBackMotor1] = nMotorEncoder[RightBackMotor1] = 0;
	// divided up into the first fourth, the middle half, the last fourth
	int x1 = distance/4;
	int x2 = distance*3/4;
	int currentSpeed;
	int newSpeed = currentSpeed;
	while(isUnderValue(x1)) {
		currentSpeed = motor[LeftBackMotor1] + motor[RightBackMotor1]/2;
		newSpeed = (currentSpeed <= 117) ? currentSpeed + 10 : 127;
		basicMove(0, newSpeed, 0);
		wait1Msec(20);
	}
	while(isUnderValue(x2)) {
		currentSpeed = motor[LeftBackMotor1] + motor[RightBackMotor1]/2;
		basicMove(0, 127, 0);
	}
	while(isUnderValue(distance)) {
		currentSpeed = motor[LeftBackMotor1] + motor[RightBackMotor1]/2;
		newSpeed = (currentSpeed >= 10) ? currentSpeed - 10 : 0;
		basicMove(0, newSpeed, 0);
		//basicMove(0, currentSpeed - 10, 0);
		wait1Msec(20);
	}
}

void forward(int distance) {
	nMotorEncoder[LeftBackMotor1] = 0;
	nMotorEncoder[RightBackMotor1] = 0;

	while(isUnderValue(distance)) {
		move(0, 127, 0);
  }
	move(0, 0, 0);
}

void back(int distance) {
	nMotorEncoder[LeftBackMotor1] = 0;
	nMotorEncoder[RightBackMotor1] = 0;

	while(isUnderValue(distance)) {
		move(0, -127, 0);
  }
	move(0, 0, 0);
	basicMove(0, 0, 0);
}

void backT(int time) {
	motor[LeftBackMotor1] = motor[LeftBackMotor2] = motor[LeftFrontMotor1] = -127;
	motor[RightBackMotor1] = motor[RightBackMotor2] = motor[RightFrontMotor1] = -127;
	wait1Msec(time);
	move(0, 0, 0);
}

void turn(int target) {
	if(morpheus == 0) {
		motor(LeftBackMotor1) = motor(LeftBackMotor2) = motor(LeftFrontMotor1) = 127;
		motor(RightBackMotor1) = motor(RightBackMotor2) = motor(RightFrontMotor1) = -127;
	}
}

void raiseArm(int target) {
	while(armRotation < target) {
		powerArm(127);
		updateSensors();
	}
}
void lowerArm(int target) {
	while(armRotation > target) {
		powerArm(-127);
		updateSensors();
	}
}

void followLine() {
	//int defaultLine = 2800;
	int leftMotor = 60, rightMotor = 60;
	//int firstDetected = 1;
	//int rightOfRight = false;
	//int leftOfLeft = true;
	int isLeft = true;
	//int timesHitLine = 0;
	nMotorEncoder[LeftBackMotor1] = nMotorEncoder[RightBackMotor1] = 0;
	while(isUnderValue(1400)) {
		if(SensorValue[LeftLine] < 2600)
		{
			if(isLeft) {
				leftMotor = 35;
				rightMotor = 70;
				isLeft = false;
				if(SensorValue[RightLine] > 2600)
					wait1Msec(40);
			}
		}
		if(SensorValue[RightLine] < 2600) {
			if(!isLeft) {
				rightMotor = 35;
				leftMotor = 70;
				isLeft = true;
				wait1Msec(40);
			}
		}
		motor(LeftBackMotor1) = motor(LeftBackMotor2) = motor(LeftFrontMotor1) = leftMotor;
		motor(RightBackMotor1) = motor(RightBackMotor2) = motor(RightFrontMotor1) = rightMotor;
	}
	basicMove(0, 0, 0);
}

void strafeUntilLine() {
	if(morpheus == 0)
		setMorpheus();
	while(SensorValue[RightLine] < 2600) {
		basicMove(0, 0, -67);
	}
	while(SensorValue[LeftLine] > 2600) {
		basicMove(0, 0, -40);
	}
	basicMove(0, 0, -127);
	wait1Msec(20);
	setTank();
}

void waitForButton() {
	while(SensorValue[Button] == 0) {
		wait1Msec(10);
	}
}

//////////////////////////////////////////////////////////////////////////
//																																			//
//													AUTONOMOUS METHODS 													//
//																																			//
//////////////////////////////////////////////////////////////////////////

void slolRof() {
	setTank();
	powerArm(0);
	raiseArm(650);
	powerArm(10);
	forward(480);
	wait1Msec(1000);
	back(500);
	basicMove(0, 0, 0);
	wait1Msec(2000);
	forward(470);
	wait1Msec(1000);
	back(450);
	basicMove(0, 0, 0);
}

void forLols() {
	setTank();
	powerArm(0);
	raiseArm(650);
	powerArm(10);
	motor[Intake1] = motor[Intake2] = -127;
	forward(430);
	wait1Msec(1000);
	back(430);
	basicMove(0, 0, 0);
	//waitForButton();
	wait1Msec(4000);
	forward(480);
	wait1Msec(1000);
	back(500);
	basicMove(0, 0, 0);
	lowerArm(0);
	motor[Intake1] = motor[Intake2] = 0;
	basicMove(0, 0, 0);
}

void hangSide() {
	motor(Intake1) =motor(Intake2) = 127;
	forward(34);
	wait1Msec(1500);
	back(60);
	basicMove(0, 0, 0);
	wait1Msec(2000);
	/*raiseArm(300);
	outtakeT(2000);*/
	motor(Intake1) = motor(Intake2) = 0;
	powerArm(0);
	basicMove(0, 0, 0);
	raiseArm(600);
	powerArm(20);
	waitForButton();
	outtakeT(3500);
	basicMove(0, 0, 0);
	powerArm(0);
	basicMove(0, 0, 0);
}

// Most basic, scores preload, knocks over big balls.
void forGreaterJustice() {
	setTank();
	forward(1100);
	raiseArm(1200);
	powerArm(10);
	//back(50);
	basicMove(0, 0, 0);
	motor(Intake1) =motor(Intake2) = -127;
	wait1Msec(800);
	back(400);
	motor(Intake1) =motor(Intake2) = 0;
	lowerArm(10);
	back(600);
	basicMove(0, 0, 0);
	waitForButton();
	// Push over big balls
	//raiseArm(650);
	powerArm(0);
	//stopArm();
	motor[Arm1] = motor[Arm2] = 0;
	forLols();
}

void forMuricaAndForAslan() {
	setTank();
	forward(1600);
	setMorpheus();
	basicMove(0, 10, -127);
	wait1Msec(1000);
	basicMove(0, 0, 0);
	raiseArm(1200);
	powerArm(10);
	setTank();
	forward(470);
	basicMove(0, 0, 0);
	outtakeT(1200);
	back(600);
	basicMove(0, 0, 0);
}

void lineFollower() {
	setMorpheus();
	strafeUntilLine();
	followLine();
}

task Display_LCD(){
  bLCDBacklight = true;
  while(true){
    // Converting autonN to a string.
    //string autonNstring = autonN;

    // Battery level indicator
    string display = "R:";
  	string regularBat, backupBat;
    StringFormat(regularBat, "%1.2f", (float)nImmediateBatteryLevel/1000);
    //StringFormat(expand_bat, "%1.2f", (float)SensorValue[]/275);
    StringFormat(backupBat, "%1.2f", (float)BackupBatteryLevel/1000);
    StringConcatenate(display, regularBat);
    StringConcatenate(display, "V B:");
    StringConcatenate(display, backupBat);
    StringConcatenate(display, "V ");

    clearLCDLine(0);
    clearLCDLine(1);

    if(vexRT[Btn7L] == 1)
    {
    	displayLCDCenteredString(0, "Battery Power:");
    	displayLCDCenteredString(1, display);
  	}
    else
    {
    	if((float)nImmediateBatteryLevel/1000 < 6.45)
    	{
    		displayLCDCenteredString(0, "***WARNING***");
    		displayLCDCenteredString(1, "*LOW BATTERY*");
    	}
    	else
    	{
    		// Default screen:
    		string left = SensorValue[LeftLine];
    		string right = SensorValue[RightLine];
    		string arm = armRotation;
    		string lolbeav = isBeingIntaken;
    		displayLCDCenteredString(0, left);
    	  displayLCDCenteredString(1, lolbeav);
    	}
    }
    wait1Msec(100);

  }
}

// COMPETITION METHODS
task autonomous()
{
	StartTask(Display_LCD);
	startAuton();
	//forGreaterJustice();
	//forMuricaAndForAslan();
	//lineFollower();
	//forLols();
	hangSide();

}

task usercontrol()
{
	nMotorEncoder[LeftBackMotor2] = 0;
	//motor[Flash] = 127;
	while (true) {
		//displayLCDCenteredString(0, "Hello");
		StartTask(Display_LCD);
		updateSensors(); // updates all sensors
		UC_drive();  // allows for movement of the robot
		UC_arm(1); // allows for movement of the arm
		UC_intake();
	}
}

/* OLD LINE FOLLOWING CODE
/*if(!rightOfRight) {
				rightOfRight = true;
				timesHitLine++;
				wait1Msec(80);
			}
			else {
				leftMotor = 30;
				rightMotor = 60;
			}*/
			//else
			//{ leftMotor = 45;
			//	rightMotor = 60; }
			//leftMotor = 45;//127 - ((2000 - SensorValue[RightLine])/8);*/
