#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(Sensor, in1,    ArmPotentiometer, sensorPotentiometer)
#pragma config(Sensor, in2,    Gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  RightMorpheus,  sensorDigitalOut)
#pragma config(Sensor, dgtl2,  LeftMorpheus,   sensorDigitalOut)
#pragma config(Motor,  port1,           Arm1,          tmotorVex393, openLoop)
#pragma config(Motor,  port2,           LeftBackMotor1, tmotorVex393HighSpeed, openLoop)
#pragma config(Motor,  port3,           LeftBackMotor2, tmotorVex393HighSpeed, openLoop)
#pragma config(Motor,  port4,           RightBackMotor1, tmotorVex393HighSpeed, openLoop, reversed)
#pragma config(Motor,  port5,           RightBackMotor2, tmotorVex393HighSpeed, openLoop, reversed)
#pragma config(Motor,  port6,           LeftFrontMotor1, tmotorVex393HighSpeed, openLoop)
#pragma config(Motor,  port7,           RightFrontMotor1, tmotorVex393HighSpeed, openLoop, reversed)
#pragma config(Motor,  port8,           IntakeLeft,    tmotorVex393, openLoop)
#pragma config(Motor,  port9,           IntakeRight,   tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(105)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

#define MOTOR_NUM               10
#define MOTOR_MAX_VALUE         127
#define MOTOR_MIN_VALUE         (-127)
#define MOTOR_DEFAULT_SLEW_RATE 10      // Default will cause 375mS from full fwd to rev
#define MOTOR_FAST_SLEW_RATE    256     // essentially turns off smoothing
#define MOTOR_TASK_DELAY        15      // task 1/frequency in mS (about 66Hz)
#define MOTOR_DEADBAND          10


#define TURN_SPEED				2		// default at 2: making it higher could destabilize turning
#define JOY_THRESHOLD			15		// threshold for not considering low joystick values (prevents drift)


int armRotation = SensorValue[ArmPotentiometer];
int morpheus = 0; // state of drive orientation: 0 = tank, 1 = x-drive
int armSpeedPrevious = 0;

int motorReq[ MOTOR_NUM ]; // Array to hold requested speed for the motors
int motorSlew[ MOTOR_NUM ]; // Array to hold "slew rate" for the motors, the maximum change every time the task runs checking current motor speed.

// Uses a cubic function to make the acceleration smooth and not jerky or sudden.
// x is the input value of the joystick, return is the y value mapped along a cubic map
int cubicMap(int x)
{
	return ((((x*3)/25)*((x*3)/25)*((x*3)/25)/27 + x/2)*2)/3;
}



/* How to use this method: MotorSlewRateTask constantly updates the motor values
 * with the input "target" value for each motor.  This task is always running!
 * It smooths acceleration in junction with the cubic map function.
 * Just use:
 * motorReq(motorname_hehe) = requestedValue;
 */

task MotorSlewRateTask()
{
    int motorIndex;
    int motorTmp;

    // Initialize stuff
    for(motorIndex = 0; motorIndex < MOTOR_NUM; motorIndex++) {
        motorReq[motorIndex] = 0;
        motorSlew[motorIndex] = MOTOR_DEFAULT_SLEW_RATE;
    }

    // run task until stopped
    while( true )
        {
        // run loop for every motor
        for( motorIndex=0; motorIndex<MOTOR_NUM; motorIndex++)
            {
            // So we don't keep accessing the internal storage
            motorTmp = motor[ motorIndex ];

            // Do we need to change the motor value ?
            if( motorTmp != motorReq[motorIndex] )
                {
                // increasing motor value
                if( motorReq[motorIndex] > motorTmp )
                    {
                    motorTmp += motorSlew[motorIndex];
                    // limit
                    if( motorTmp > motorReq[motorIndex] )
                        motorTmp = motorReq[motorIndex];
                    }

                // decreasing motor value
                if( motorReq[motorIndex] < motorTmp )
                    {
                    motorTmp -= motorSlew[motorIndex];
                    // limit
                    if( motorTmp < motorReq[motorIndex] )
                        motorTmp = motorReq[motorIndex];
                    }

                // finally set motor
                motor[motorIndex] = motorTmp;
                }
            }

        // Wait approx the speed of motor update over the spi bus
        wait1Msec( MOTOR_TASK_DELAY );
        }
}

task UC_Drive()
{

	int channel1 = cubicMap(vexRT[Ch1]); // variables for joystick values
	int channel3 = cubicMap(vexRT[Ch3]);
	int channel4 = cubicMap(vexRT[Ch4]);

	while (true) {

		channel1 = cubicMap(vexRT[Ch1]);
		channel3 = cubicMap(vexRT[Ch3]);
		channel4 = cubicMap(vexRT[Ch4]);

		if( (abs(channel1) <= JOY_THRESHOLD) && (abs(channel3) <= JOY_THRESHOLD) && (abs(channel4) <= JOY_THRESHOLD)  ) {
		    motorReq[LeftFrontMotor1] = motorReq[LeftBackMotor1] = motorReq[LeftBackMotor2] = motorReq[RightFrontMotor1] = motorReq[RightBackMotor1] = motorReq[RightBackMotor2] = 0;
		} else {
			if(morpheus == 0) {  // tank drive  // might have to switch all round brackets with square brackets for motorReq[stuff]
  				motorReq[LeftFrontMotor1] = motorReq[LeftBackMotor1] = motorReq[LeftBackMotor2] = channel3 + TURN_SPEED*channel1;
				motorReq[RightFrontMotor1] = motorReq[RightBackMotor1] = motorReq[RightBackMotor2] = channel3 - TURN_SPEED*channel1;
			} else {
				// x-drive
  				motorReq[LeftFrontMotor1] = channel3 + channel4 + channel1;
  				motorReq[RightFrontMotor1] = channel3 - channel4 - channel1;
  				motorReq[LeftBackMotor1] = motorReq[LeftBackMotor2] = channel3 - channel4 + channel1;
  				motorReq[RightBackMotor1] = motorReq[RightBackMotor2] = channel3 + channel4 - channel1;
			}

		}

		// at this point, all the drive variables have had their values set
	    wait1Msec(25);
	}
}

// All activities that occur before the competition starts
// Example: clearing encoders, setting servo positions, ...
void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
  // Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;
}


void updateSensors() {
  	armRotation = SensorValue[ArmPotentiometer];
}

// allocates the specified arm power to the arm motors
void powerArm(int speed) {
	motor(Arm) = speed;
}

// brings the arm to a gradual stop
void stopArm() {
	if (armSpeedPrevious > 10) {
		armSpeedPrevious -= 1;
		powerArm(armSpeedPrevious);
	} else if(armSpeedPrevious < -10) {
		armSpeedPrevious += 1;
		powerArm(armSpeedPrevious);
	}
}

// controls the algorithm in determining arm speed
void moveArm(int target) {
	if(target > 0) {
		int tempSpeed = armSpeedPrevious + ((127-armSpeedPrevious)/5);
		powerArm(tempSpeed);
		armSpeedPrevious = tempSpeed;
	} else if (target < 0) {
		int tempSpeed = armSpeedPrevious - ((127+armSpeedPrevious)/5);
		powerArm(tempSpeed);
		armSpeedPrevious = tempSpeed;
	} else {
		stopArm();
	}
}

// controls arm movement of robot
void UC_arm(bool safe) {
	if(safe) {
		if (vexRT[Btn5U] == 1 && vexRT[Btn5D] == 1) {
	    	moveArm(0);
	 	} else if (vexRT[Btn5U] == 1) {  	 // bring the arm up
	    	moveArm(127);
		} else if (vexRT[Btn5D] == 1) {	 // bring the arm down
	      moveArm(-127);
	    } else {											// don't do anything to the arm
	      moveArm(0);
	    }
	} else {
		if (vexRT[Btn5U] == 1 && vexRT[Btn5D] == 1) {
	    	moveArm(0);
	 	} else if (vexRT[Btn5U] == 1) {  	 // bring the arm up
	    	moveArm(127);
		} else if (vexRT[Btn5D] == 1) {	 // bring the arm down
	      moveArm(-127);
	    } else {						// don't do anything to the arm
	      moveArm(0);
	    }
	}
}

bool toggle(bool a) {
	return !a;
}

// COMPETITION METHODS
task autonomous()
{

}

task usercontrol()
{

	// Start motor slew rate control
    StartTask( MotorSlewRateTask );

    // Start driver control tasks
    StartTask( UC_Drive );


	while (true) {
		updateSensors(); // updates all sensors

		if(vexRT[Btn8L]) {
			morpheus = 1;
		} else if (vexRT[Btn8R]) {
			morpheus = 0;
		}
		// "morpheus" variable is state of x-holo or tank, RightMorpheus and LeftMorpheus are
		// the pneumatic pistons controlling the left and right of the drive
		SensorValue[RightMorpheus] = morpheus;
		SensorValue[LeftMorpheus] = morpheus;


		UC_arm(1); // allows for movement of the arm

	}
}
